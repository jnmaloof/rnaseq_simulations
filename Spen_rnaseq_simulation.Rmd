---
title: "Spen_rnaseq_simulation"
author: "Julin Maloof"
date: "November 29, 2015"
output: html_document
---

I want to determine how well various aligners perform when mapping S. pennellii RNAseq reads to the Heinz genome.  The basic method will be to simulate reads from fasta files, map, and then compare results to reality.

I will start just with S.pen but will move on to differential expression analysis between M82 and S.pen.

I plan to compare

* stampy
* subread
* star
* bowtie

## preliminaries

### Install Polyester

Use the [Polyester package](http://bioconductor.org/packages/release/bioc/vignettes/polyester/inst/doc/polyester.html)  to simulate RNAseq reads.  Also see the [Polyester paper.](http://bioinformatics.oxfordjournals.org/content/31/17/2778)

Installation.  Only needs to be run once per computer.
```{r install_polyester, eval=FALSE}
source("http://bioconductor.org/biocLite.R")
biocLite("polyester")
```


### Install STAR (only needs to be done once)
(NOTE THAT VERSION 2.5 IS NEEDED AND THIS IS NOT CURRENTLY IN HOMEBREW)
```{r install_STAR eval=FALSE, engine='bash'}
brew install rna-star
brew install gcc5 
```

### libraries, etc

```{r}
library(polyester)
library(Biostrings)
library(ggplot2)
library(Rsamtools)
library(rtracklayer)
library(Rsubread)
library(R.utils)
setwd("~/Documents/Lab Notebook support/2015/rnaseq_simulations")
source("Rnaseq_sim_helper_functions.R")
```


### Define some useful functions



## Simluate reads (simple version)

Load Spen and Slyc transcripts  
Spen CDS fasta can be obtained from [SGN](ftp://ftp.solgenomics.net/genomes/Solanum_pennellii/annotations/)
slyc fasta is also from [SGN](ftp://ftp.sgn.cornell.edu/genomes/Solanum_lycopersicum/annotation/ITAG2.4_release/)
```{r load_Spen, eval=FALSE}
pen.transcripts <-  readDNAStringSet("~/Sequences/ref_genomes/S.pen/Spenn-v2-cds-annot.fa")
head(pen.transcripts)
names(pen.transcripts[1:10])
lyc.transcripts <- readDNAStringSet("~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_cds.fasta")
head(lyc.transcripts)
names(lyc.transcripts)[1:10]
```

Reformat names to get rid of description and add Slyc reference
```{r reformat_gene_names, eval=FALSE}
orthologs <- read.delim("Ortho_v2.txt",header=FALSE) #From Tony Bolger
head(orthologs)
names(orthologs) <- c("PEN","LYC")
orthologs$PEN <- sub("t","",orthologs$PEN)
head(orthologs)
orthologs$PEN.LYC <- paste(orthologs$PEN,orthologs$LYC,sep="_")
names(pen.transcripts) <- substr(names(pen.transcripts),1,16)
names(pen.transcripts) <- ifelse(!is.na(match(names(pen.transcripts),orthologs$PEN)),
                                 orthologs$PEN.LYC[match(names(pen.transcripts),orthologs$PEN)],
                                 names(pen.transcripts))
pen.transcripts

names(lyc.transcripts) <- substr(names(lyc.transcripts),1,18)
names(lyc.transcripts) <- ifelse(!is.na(match(names(lyc.transcripts),orthologs$LYC)),
                                 orthologs$PEN.LYC[match(names(lyc.transcripts),orthologs$LYC)],
                                 names(lyc.transcripts))
pen.gene.length <- as.integer(nchar(pen.transcripts))
names(pen.gene.length) <- names(pen.transcripts)
lyc.gene.length <- as.integer(nchar(lyc.transcripts))
names(lyc.gene.length) <- names(lyc.transcripts)
```

Lets limit ourselves to genes where orthology is clear:
```{r reduce_data, eval=FALSE}
pen.transcripts.small <- pen.transcripts[nchar(names(pen.transcripts))>16]
writeXStringSet(pen.transcripts.small,file="~/Sequences/ref_genomes/S.pen/Spenn-v2-cds-annot_orthlogs_only.fa")
lyc.transcripts.small <- lyc.transcripts[nchar(names(lyc.transcripts)) > 18]
writeXStringSet(lyc.transcripts.small,file="~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_cds.pen.orthologs.only.fasta")
```

Simulate PEN RNAseq reads
```{r simulate_pen_1, eval=FALSE}
#3 minutes for 1M reads
#15 minutes for 5M reads
system.time(
  simulate_experiment(fasta="~/Sequences/ref_genomes/S.pen/Spenn-v2-cds-annot_orthlogs_only.fa",
                      outdir="spen_sim_1",
                      num_reps=1,
                      readlen=45,
                      #line below gives ~ 5M reads, scaled by transcript length
                      reads_per_transcript = round(width(pen.transcripts.small) * 
                                                     5e6/ sum(width(pen.transcripts.small) )),
                      paired=FALSE,
                      error_model="illumina5",
                      bias="rnaf"
  )
)
system("sed 's!/!;!' spen_sim_1/sample_01.fasta > spen_sim_1/sample_01_renamed.fasta") #this allows original gene_names to be kept
system("rm spen_sim_1/sample_01.fasta")
system("gzip spen_sim_1/sample_01_renamed.fasta")
```

Simulate LYC RNAseq reads
```{r simulate_lyc_1, eval=FALSE}
system.time(
  simulate_experiment(fasta="~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_cds.pen.orthologs.only.fasta",
                      outdir="slyc_sim_1",
                      num_reps=1,
                      readlen=45,
                      #line below gives ~ 5M reads, scaled by transcript length
                      reads_per_transcript = round(width(lyc.transcripts.small) * 
                                                     5e6/ sum(width(pen.transcripts.small) )),
                      paired=FALSE,
                      error_model="illumina5",
                      bias="rnaf"
  )
)
system("sed 's!/!;!' slyc_sim_1/sample_01.fasta > slyc_sim_1/sample_01_renamed.fasta") #this allows original gene_names to be kept
system("rm slyc_sim_1/sample_01.fasta")
system("gzip slyc_sim_1/sample_01_renamed.fasta")
```

### calculate known counts

use external python script
```{r known_counts}
pen.known.counts <- read.table(pipe("./CountGene.py spen_sim_1/sample_01_renamed.fasta.gz"),col.names=c("id","count"),stringsAsFactors = FALSE)
pen.known.counts$lyc.id <- substr(pen.known.counts$id,18,33)
head(pen.known.counts)

lyc.known.counts <- read.table(pipe("./CountGene.py slyc_sim_1/sample_01_renamed.fasta.gz"),col.names=c("id","count"),stringsAsFactors = FALSE)
lyc.known.counts$lyc.id <- substr(lyc.known.counts$id,18,33)
head(lyc.known.counts)
```

## Map with star

### Create genome file
Only needs to be done once  
This is a shell command  
Takes about 25 minutes  
```{r create_genome_file, eval=FALSE, engine='bash'}
gffread -T ITAG2.4_gene_models.gff3 -o ITAG2.4_gene_models.gtf
STAR --runThreadN 6 --runMode genomeGenerate --genomeDir ~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/STAR_genome --genomeFastaFiles ~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/S_lycopersicum_chromosomes.2.50.fa --sjdbGTFfile ~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_gene_models.gtf
```

### Create parameters files
```{r STAR_params_1, eval=FALSE, engine='bash'}
cat > STAR.params.whitney.1
genomeDir /Network/Servers/avalanche.plb.ucdavis.edu/Volumes/Mammoth/Users/jmaloof/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/STAR_genome
outSAMtype BAM SortedByCoordinate
outSAMunmapped Within
quantMode GeneCounts

cat > STAR.params.royce.1
genomeDir /Users/jmaloof/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/STAR_genome
outSAMtype BAM SortedByCoordinate
outSAMunmapped Within
quantMode GeneCounts

```

### Run it!
```{r RunStar_1, eval=FALSE}
RunStar(fasta="sample_01_renamed.fasta.gz",prefix = "STAR_1",dir="spen_sim_1",n=2)
RunStar(fasta="sample_01_renamed.fasta.gz",prefix = "STAR_1",dir="slyc_sim_1",n=2)
```
__note__ I needed to use STAR2.5 for this to work.

## Evaluate results

We want to do:

* correlation between known counts and found counts
* how many reads map to the wrong gene?
* how many reads do not map?
* something about splice junctions

### Load in mapped counts
```{r get_mapped_counts }
pen.mapped.counts <- GetMappedCounts(prefix = "STAR_1", dir = "spen_sim_1")
lyc.mapped.counts <- GetMappedCounts(prefix = "STAR_1", dir = "slyc_sim_1")
```

### Comparison

```{r compare_spen1}
pen.count.comparison.1 <- CompareCounts(pen.known.counts, pen.mapped.counts, title = "S. pen.  STAR mapped.  Default parameters")
lyc.count.comparison.1 <- CompareCounts(lyc.known.counts, lyc.mapped.counts, title = "S. lyc.  STAR mapped.  Default parameters")
```

Investigate...
Lets take a look at the bam file and extract reads from a few genes with 0 mapped reads.  Skip chromosome 0
```{r}
reads <- scanBam(file="spen_sim_1/STAR_1Aligned.sortedByCoord.out.bam",
                 param = ScanBamParam(what=scanBamWhat(),
                                      tag=c("NH","HI","AS","nM")))[[1]]
#note: DO NOT directly convert reads to a data frame.  Uses lots of memory.  instead remove the very large reads column.  See below.

reads <- c(reads[names(reads)!="tag"],reads$tag) #unpack each element of reads$tag and add it to reads

#add an element indicating whether or not the read came from a gene with no reads mapping to the pen version
genes.zero.map <- pen.count.comparison.1$id[pen.count.comparison.1$count.known>0 & pen.count.comparison.1$count.mapped==0]
reads$gene <- unlist(strsplit(reads$qname,";"))[c(FALSE,TRUE,FALSE,FALSE)]
lapply(reads, head)
reads$pen.zero.map <- reads$gene %in% genes.zero.map

table(reads$flag,reads$pen.zero.map)
table(reads$NH,reads$pen.zero.map) #number of hits

reads.df <- with(reads,data.frame(qname,rname,pos,qwidth,flag,cigar,NH,HI,AS,nM,gene,pen.zero.map,stringsAsFactors=FALSE))
reads.df$gene.lyc <- substr(reads.df$gene,18,38)
  
reads.df$multimap <- reads.df$NH>1

reads.df$pen.gene.length <- pen.gene.length[reads.df$gene]
reads.df$lyc.gene.length <- lyc.gene.length[reads.df$gene]

reads.df$pen.lyc.gene.length.dif <- reads.df$pen.gene.length - reads.df$lyc.gene.length

reads.df$pen.lyc.gene.length.ratio <- reads.df$pen.gene.length / reads.df$lyc.gene.length

ggplot(reads.df,aes(x=as.factor(NH),y=nM,group=NH)) + geom_point(stat="sum") + scale_size(breaks=seq(0,1,.1),range=c(1,15))

ggplot(reads.df,aes(x=as.factor(NH),y=pen.gene.length,fill=pen.zero.map)) + geom_violin()

ggplot(reads.df,aes(x=as.factor(NH),y=lyc.gene.length,fill=pen.zero.map)) + geom_violin()

ggplot(reads.df,aes(x=as.factor(NH),y=pen.gene.length)) + geom_violin()

ggplot(reads.df,aes(x=as.factor(NH),y=pen.lyc.gene.length.ratio,fill=multimap)) + geom_violin()

ggplot(reads.df,aes(x=pen.zero.map,y=pen.gene.length,fill=multimap)) + geom_boxplot()

ggplot(reads.df,aes(x=pen.zero.map,y=pen.lyc.gene.length.ratio,fill=multimap)) + geom_violin()

#maybe better to look at this gene_length thing on a per gene basis

ggplot(pen.count.comparison.1,aes(x=gene.length.diff.pen.lyc,y=count.ratio.known.mapped)) + geom_point(alpha=0.1) + scale_y_log10() + scale_x_log10(breaks=c(1,10,100,200,300,500,1000))

ggplot(pen.count.comparison.1,aes(x=gene.length.ratio.pen.lyc,y=count.ratio.known.mapped))  + scale_y_log10() + scale_x_log10(breaks=c(.1,.5,seq(1,2,.2),3,5,10)) + geom_hline(yintercept=1,color="blue") + geom_vline(xintercept=1,color="blue") + geom_point(alpha=.1)

#reasonable cutoffs might be a gene.length.ratio > 1.3 or a gene length difference of > 300

pen.count.comparison.1.cutoff1.3 <- pen.count.comparison.1[pen.count.comparison.1$gene.length.ratio.pen.lyc < 1.3,]
nrow(pen.count.comparison.1)
nrow(pen.count.comparison.1.cutoff1.3)
with(pen.count.comparison.1.cutoff1.3,cor(count.known,count.mapped))

pen.count.comparison.1.cutoff300 <- pen.count.comparison.1[pen.count.comparison.1$gene.length.diff.pen.lyc < 300,]
nrow(pen.count.comparison.1)
nrow(pen.count.comparison.1.cutoff300)
with(pen.count.comparison.1.cutoff300,cor(count.known,count.mapped))

pen.count.comparison.1.cutoff300.1.3 <- pen.count.comparison.1[pen.count.comparison.1$gene.length.diff.pen.lyc < 300 & pen.count.comparison.1$gene.length.ratio.pen.lyc < 1.3,]
nrow(pen.count.comparison.1)
nrow(pen.count.comparison.1.cutoff300.1.3)
with(pen.count.comparison.1.cutoff300.1.3,cor(count.known,count.mapped))

length.cutoff.plot.data <- as.data.frame(t(sapply(seq(0,max(pen.count.comparison.1$gene.length.diff.pen.lyc),50),function(x) 
  with(
    pen.count.comparison.1[pen.count.comparison.1$gene.length.diff.pen.lyc <= x ,],
    c(cutoff=x,genes=length(count.known),correlation=cor(count.known,count.mapped))))))
length.cutoff.plot.data$type <- "difference"


ratio.cutoff.plot.data <- as.data.frame(t(sapply(seq(1,max(pen.count.comparison.1$gene.length.ratio.pen.lyc),.1),function(x) 
  with(
    pen.count.comparison.1[pen.count.comparison.1$gene.length.ratio.pen.lyc <= x ,],
    c(cutoff=x,genes=length(count.known),correlation=cor(count.known,count.mapped))))))
ratio.cutoff.plot.data$type <- "ratio"

combined.cutoff.plot.data <-rbind(length.cutoff.plot.data,ratio.cutoff.plot.data)

ggplot(combined.cutoff.plot.data,aes(x=genes,y=correlation,color=type)) + geom_line() 

ggplot(length.cutoff.plot.data,aes(x=genes,y=correlation,label=cutoff)) + geom_line() + geom_text(aes(label=cutoff),size=2.5,vjust=-1,hjust=-.3) 
```

how many reads map to the wrong gene?

note: there is ranges data for each read mapping.  So I can compare that to the GTF ranges.
```{r mismapping}
lyc.transcript.gr <- import("~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_gene_models.gff3",feature.type="mRNA")
reads.df.map <- na.omit(reads.df)
reads.gr <- with(reads.df.map,GRanges(seqnames=rname,
                    ranges = IRanges(start=pos,
                                     width = qwidth, #note that this is not precisely correct because of introns,etc
                                     names=qname)))
hits <- findOverlaps(reads.gr,lyc.transcript.gr,ignore.strand=TRUE)
sum(reads.df.map$gene.lyc[queryHits(hits)] != lyc.transcript.gr$Name[subjectHits(hits)]) / length(hits)
reads.df.map.single <- reads.df.map[reads.df.map$NH==1,]
reads.gr.single <- with(reads.df.map.single,GRanges(seqnames=rname,
                    ranges = IRanges(start=pos,
                                     width = qwidth, #note that this is not precisely correct because of introns,etc
                                     names=qname)))
hits.single <- findOverlaps(reads.gr.single,lyc.transcript.gr,ignore.strand=TRUE)
sum(reads.df.map.single$gene.lyc[queryHits(hits.single)] != lyc.transcript.gr$Name[subjectHits(hits.single)]) / length(hits.single)

reads.df.map.single.overlap <- reads.df.map.single[queryHits(hits.single),] #only keep reads that overlap a transcript

reads.df.map.single.overlap$gene.mapped.to <- lyc.transcript.gr$Name[subjectHits(hits.single)]

#remove chromosome zero

reads.df.map.single.overlap <- reads.df.map.single.overlap[!grepl("Solyc00g",paste(reads.df.map.single.overlap$gene.lyc,reads.df.map.single.overlap$gene.mapped.to)),] #not very different

with(reads.df.map.single.overlap,sum(gene.lyc!=gene.mapped.to)/length(gene.lyc))

#are reads represented more than once?
length(unique(reads.df.map.single.overlap$qname))/nrow(reads.df.map.single.overlap)
#yes.  So reads are overlapping with multiple genes.  Presumably this is due to overlaping genes in the annotation.

reads.df.map.single.overlap$chrom.lyc <- substr(reads.df.map.single.overlap$gene.lyc,6,8)
reads.df.map.single.overlap$chrom.mapped.to <- substr(reads.df.map.single.overlap$gene.mapped.to,6,8)


reads.df.map.single.overlap$mismap <- reads.df.map.single.overlap$gene.lyc != reads.df.map.single.overlap$gene.mapped.to
head(reads.df.map.single.overlap,50)
head(reads.df.map.single.overlap[reads.df.map.single.overlap$mismap,c("gene.lyc","gene.mapped.to")],50)
#yes the overlapping annotaiton seems to explain some of it.  Can check more
reads.df.map.single.overlap <- within(reads.df.map.single.overlap, mapnear <- 
                                        (abs(as.numeric(substr(gene.lyc,9,14)) - as.numeric(substr(gene.mapped.to,9,14))) < 40) & 
                                        chrom.lyc == chrom.mapped.to)
head(reads.df.map.single.overlap[reads.df.map.single.overlap$mismap,c("gene.lyc","gene.mapped.to","mapnear")],100)
with(reads.df.map.single.overlap,sum(mapnear & mismap) / sum(mismap))

#so if we get rid of the "mapnear" mismaps how many mismaps are left?
sum(reads.df.map.single.overlap$mismap[!reads.df.map.single.overlap$mapnear]) / nrow(reads.df.map.single.overlap)

#save.image("rnaseqSim.Rdata")
```

Next steps: some comparative genomic alignments for the genes that aren't behaving well.  (ideas: BLAT produces PSL files and IGV can read those.  Or use STAR.  Or use BLAST and the blast2sam).

```{r BLAT install, eval=FALSE, engine='bash'}
brew install blat
```

```{r run BLAT, engine='bash', eval=FALSE}
blat ~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/S_lycopersicum_chromosomes.2.50.fa ~/Sequences/ref_genomes/S.pen/Spenn-v2-cds-annot_orthlogs_only.fa -maxIntron=20000 penCDS_to_lycGENME.psl
```

Map _real_ reads as comparision
```{r map_real,eval=FALSE}
RunStar(fasta = "/Volumes/temp-o-matic/temp_SolRAID_restore/Solexa_runs_Data/Filtered_fastq_by_seedling_exp/merged_files/PEN.seedlings.fq",
        prefix = "STAR_1",
        dir = "spen_real",
        n=12,
        param.file = "../STAR.params.whitney.1")
```


Now look in IGV (Note: Need to use IGVtools to sort and index the .psl file)

```{r}
head(reads.df.map.single.overlap[reads.df.map.single.overlap$mismap,c("qname","gene.lyc","gene.mapped.to","mapnear")],100)
sort(table(reads.df.map.single.overlap$gene.lyc[reads.df.map.single.overlap$mismap]))
```

### 5 examples of genes with mismapping

Solyc02g090930.2.1 (12): Tandem Repeat with Solyc02g090940.2.1
Solyc04g072480.2.1 (30): Nothing obviously strange
Solyc03g051930.2.1 (70): PEN gene spans two LYC genes
Solyc02g079850.2.1 (150): PEN gene spans two LYC genes
Solyc01g110960.2.1 (497): Much Confusion

### 5 examples of genes with zero mapping

```{r}
pen.count.comparison.1.cutoff300.1.3[pen.count.comparison.1.cutoff300.1.3$count.ratio==Inf,c("lyc.id","count.known","gene.length.ratio.pen.lyc")]
```

Solyc01g010050.2: Two overlapping LYC transcripts
Solyc01g060020.2: Multiple overlapping LYC transcripts
Solyc05g023780.1: Repetitive region
Solyc08g015710.1: Very small region of homology
Solyc11g056540.1: BLAT did not find a match

NEXT STEP: 
* ELIMINATE GENES WITH OVERLAPPING LYC TO LYC OR PEN TO LYC TRANSCRIPTS.  
* ALSO TRY DIFFERENT READ COUNTING METHOD
* USE BLAT TO ELIMINATE TRANSCRIPTS WITH POOR HOMOLOGY

