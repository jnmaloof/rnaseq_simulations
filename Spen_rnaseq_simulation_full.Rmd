---
title: "S. pennellii RNAseq simulations"
author: "Julin Maloof"
date: "July 22, 2016"
output:
  revealjs::revealjs_presentation:
    reveal_options:
      width: 1200
      height: 800
---

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(cache.lazy=FALSE)
opts_chunk$set(cache=TRUE)
opts_chunk$set(warnings=FALSE)
opts_chunk$set(messages=FALSE)
```


# Introduction

## Overall Question

When mapping RNAseq reads from a heterologous species to a reference genome, what is the best way to perform the mapping?

For example:

  > - We have a tomato reference genome
  > - We want to do RNAseq on a variety of wild relatives of tomato for which we have no genome

## Strategy: simulation

> * Use _S. pennellii_ and _S. lycopersium_.  Both are sequenced.  
> * Simulate RNASeq reads from _S. pennellii_ and map to _S. lycopersicum_.
> * Compare actual (simulated) counts to the number of counts that map.

> * Can compare different aligners:
      * [stampy](http://www.well.ox.ac.uk/project-stampy)
      * [subread](http://bioinf.wehi.edu.au/subread/)
      * [STAR](https://github.com/alexdobin/STAR)
      * [bowtie2](http://bowtie-bio.sourceforge.net/bowtie2/index.shtml)
      * [BWA](http://bio-bwa.sourceforge.net/)
      * [Kallisto](https://pachterlab.github.io/kallisto/)

> * And different parameters with those aligners.

# Preliminaries

## Install Polyester

Use the [Polyester package](http://bioconductor.org/packages/release/bioc/vignettes/polyester/inst/doc/polyester.html)  to simulate RNAseq reads.  Also see the [Polyester paper.](http://bioinformatics.oxfordjournals.org/content/31/17/2778)

Installation.  Only needs to be run once per computer.
```{r install_polyester, eval=FALSE}
source("http://bioconductor.org/biocLite.R")
biocLite("polyester")
```

## Install STAR (only needs to be done once)
```{r install_STAR, eval=FALSE, engine='bash'}
brew install rna-star
brew install gcc5 
```

## load libraries and helper scripts
```{r load_libraries, cache=FALSE}
library(polyester)
library(Biostrings)
library(ggplot2)
library(Rsamtools)
library(rtracklayer)
library(Rsubread)
library(R.utils)
library(plyr)
setwd("~/Documents/Lab Notebook support/2015/rnaseq_simulations")
source("Rnaseq_sim_helper_functions.R")
```

## Simluate reads (simple version)
Load Spen and Slyc transcripts  
Spen CDS fasta can be obtained from [SGN](ftp://ftp.solgenomics.net/genomes/Solanum_pennellii/annotations/)
slyc fasta is also from [SGN](ftp://ftp.sgn.cornell.edu/genomes/Solanum_lycopersicum/annotation/ITAG2.4_release/)
```{r load_transcripts, eval=TRUE}
pen.transcripts <-  readDNAStringSet("~/Sequences/ref_genomes/S.pen/Spenn-v2-cds-annot.fa")
head(pen.transcripts)
names(pen.transcripts[1:10])
lyc.transcripts <- readDNAStringSet("~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_cds.fasta")
head(lyc.transcripts)
names(lyc.transcripts)[1:10]
```

## Reformat names to get rid of description and add Slyc reference
```{r reformat_gene_names, eval=TRUE}
orthologs <- read.delim("Ortho_v2.txt",header=FALSE) #From Tony Bolger
head(orthologs)
names(orthologs) <- c("PEN","LYC")
orthologs$PEN <- sub("t","",orthologs$PEN)
orthologs$PEN.LYC <- paste(orthologs$PEN,orthologs$LYC,sep="_")
names(pen.transcripts) <- substr(names(pen.transcripts),1,16)
names(pen.transcripts) <- ifelse(!is.na(match(names(pen.transcripts),orthologs$PEN)),
                                 orthologs$PEN.LYC[match(names(pen.transcripts),orthologs$PEN)],
                                 names(pen.transcripts))
pen.transcripts

names(lyc.transcripts) <- substr(names(lyc.transcripts),1,18)
names(lyc.transcripts) <- ifelse(!is.na(match(names(lyc.transcripts),orthologs$LYC)),
                                 orthologs$PEN.LYC[match(names(lyc.transcripts),orthologs$LYC)],
                                 names(lyc.transcripts))
pen.gene.length <- as.integer(nchar(pen.transcripts))
names(pen.gene.length) <- names(pen.transcripts)
lyc.gene.length <- as.integer(nchar(lyc.transcripts))
names(lyc.gene.length) <- names(lyc.transcripts)
```

## Limit ourselves to genes where orthology is clear:
```{r reduce_data, eval=TRUE}
pen.transcripts.small <- pen.transcripts[nchar(names(pen.transcripts))>16]
lyc.transcripts.small <- lyc.transcripts[nchar(names(lyc.transcripts)) > 18]

if(! file.exists("~/Sequences/ref_genomes/S.pen/Spenn-v2-cds-annot_orthlogs_only.fa")) writeXStringSet(pen.transcripts.small,file="~/Sequences/ref_genomes/S.pen/Spenn-v2-cds-annot_orthlogs_only.fa")

if(! file.exists("~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_cds.pen.orthologs.only.fasta")) writeXStringSet(lyc.transcripts.small,file="~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_cds.pen.orthologs.only.fasta")
```

## Simulate PEN RNAseq reads
```{r simulate_pen_2, eval=FALSE}
#3 minutes for 1M reads
#15 minutes for 5M reads
system.time(
  simulate_experiment(fasta="~/Sequences/ref_genomes/S.pen/Spenn-v2-cds-annot_orthlogs_only.fa",
                      outdir="spen_sim_2",
                      num_reps=1,
                      readlen=45,
                      #line below gives ~ 10M reads, scaled by transcript length and following a rexp distribution
                      reads_per_transcript = round(rexp(n=length(pen.transcripts.small)) * width(pen.transcripts.small) * 
                                                     1e7/ sum(width(pen.transcripts.small) ))+1,
                      paired=FALSE,
                      error_model="illumina5",
                      bias="rnaf"
  )
)
system("sed 's!/!;!' spen_sim_2/sample_01.fasta > spen_sim_2/sample_01_renamed.fasta") #this allows original gene_names to be kept
system("rm spen_sim_2/sample_01.fasta")
system("gzip spen_sim_2/sample_01_renamed.fasta")
```

## Simulate LYC RNAseq reads
```{r simulate_lyc_2, eval=FALSE}
system.time(
  simulate_experiment(fasta="~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_cds.pen.orthologs.only.fasta",
                      outdir="slyc_sim_2",
                      num_reps=1,
                      readlen=45,
                      #line below gives ~ 10M reads, scaled by transcript length and following a rexp distribution
                      reads_per_transcript = round(rexp(n=length(lyc.transcripts.small)) * width(lyc.transcripts.small) * 
                                                     1e7/ sum(width(lyc.transcripts.small) ))+1,
                      paired=FALSE,
                      error_model="illumina5",
                      bias="rnaf"
  )
)
system("sed 's!/!;!' slyc_sim_2/sample_01.fasta > slyc_sim_2/sample_01_renamed.fasta") #this allows original gene_names to be kept
system("rm slyc_sim_2/sample_01.fasta")
system("gzip slyc_sim_2/sample_01_renamed.fasta")
```

## calculate known counts

Use external python script
```{r known_counts}
pen.known.counts <- read.table(pipe("./CountGene.py spen_sim_2/sample_01_renamed.fasta.gz"),col.names=c("id","count"),stringsAsFactors = FALSE)
pen.known.counts$lyc.id <- substr(pen.known.counts$id,18,33)
head(pen.known.counts)

lyc.known.counts <- read.table(pipe("./CountGene.py slyc_sim_2/sample_01_renamed.fasta.gz"),col.names=c("id","count"),stringsAsFactors = FALSE)
lyc.known.counts$lyc.id <- substr(lyc.known.counts$id,18,33)
head(lyc.known.counts)
```

# Map with star

## Create genome file
Only needs to be done once  
This is a shell command  
Takes about 25 minutes  
```{r create_genome_file, eval=FALSE, engine='bash'}
gffread -T ITAG2.4_gene_models.gff3 -o ITAG2.4_gene_models.gtf
STAR --runThreadN 6 --runMode genomeGenerate --genomeDir ~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/STAR_genome --genomeFastaFiles ~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/S_lycopersicum_chromosomes.2.50.fa --sjdbGTFfile ~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_gene_models.gtf
```

## Create parameters files 
```{r STAR_params_1_whitney, eval=FALSE, engine='bash'}
cat > STAR.params.whitney.1
genomeDir /Network/Servers/avalanche.plb.ucdavis.edu/Volumes/Mammoth/Users/jmaloof/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/STAR_genome
outSAMtype BAM SortedByCoordinate
outSAMunmapped Within
quantMode GeneCounts
```

```{r STAR_params_1_royce, eval=FALSE, engine='bash', include=FALSE}
cat > STAR.params.royce.1
genomeDir /Users/jmaloof/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/STAR_genome
outSAMtype BAM SortedByCoordinate
outSAMunmapped Within
quantMode GeneCounts
```

## Run it!
```{r RunStar_1, eval=FALSE}
RunStar(fasta="sample_01_renamed.fasta.gz",prefix = "STAR_1", param.file = "../STAR.params.whitney.1", dir="spen_sim_2",n=12)
RunStar(fasta="sample_01_renamed.fasta.gz",prefix = "STAR_1", param.file = "../STAR.params.whitney.1", dir="slyc_sim_2",n=12)
```

# Evaluate results from STAR

## We want to do:

* correlation between known counts and found counts
* how many reads map to the wrong gene?
* how many reads do not map?
* are the splice junctions correct?

## Load in mapped counts
```{r get_mapped_counts }
#using the STAR built-in counter
#pen.mapped.counts.STAR <- GetMappedCounts(prefix = "STAR_1", dir = "spen_sim_2")
#lyc.mapped.counts.STAR <- GetMappedCounts(prefix = "STAR_1", dir = "slyc_sim_2")
#using featureCounts from Rsubread
pen.mapped.counts <- GetMappedCounts(prefix = "STAR_1", dir = "spen_sim_2", type="STAR-featureCounts")
lyc.mapped.counts <- GetMappedCounts(prefix = "STAR_1", dir = "slyc_sim_2", type="STAR-featureCounts")
```

## _S. pennellii_
Compare known to mapped counts  
```{r compare_spen1, echo=FALSE, results='hide', fig.width=8, fig.height=5}
# pen.count.comparison.1.STAR <- CompareCounts(pen.known.counts, pen.mapped.counts.STAR, title = "S. pen.  STAR mapped.  Default parameters")
pen.count.comparison.1 <- CompareCounts(pen.known.counts, pen.mapped.counts, chrom.separate=FALSE, title = "S. pen.  STAR mapped.  Default parameters.  FeatureCounts counting")
```

For many genes this is pretty good, but for some it is pretty poor.  Is this due to S. pen?

## _S. lycopersicum_
Compare known to mapped counts  
```{r compare_slyc1, echo=FALSE, results='hide', fig.width=8, fig.height=5}
# lyc.count.comparison.1.STAR <- CompareCounts(lyc.known.counts, lyc.mapped.counts.STAR, title = "S. lyc.  STAR mapped.  Default parameters")
lyc.count.comparison.1 <- CompareCounts(lyc.known.counts, lyc.mapped.counts, chrom.separate=FALSE, title = "S. lyc.  STAR mapped.  Default parameters FeatureCounts counting")
```

_S. lyc_ maps much better.  What is messing up the _S. pen_ mapping?

##Investigate...
Lets take a look at the bam file and extract reads from a few genes with 0 mapped reads.
```{r read_bam, echo=FALSE,results='hide'}
reads <- scanBam(file="spen_sim_2/STAR_1Aligned.sortedByCoord.out.bam",
                 param = ScanBamParam(what=scanBamWhat(),
                                      tag=c("NH","HI","AS","nM")))[[1]]
#note: DO NOT directly convert reads to a data frame.  Uses lots of memory.  instead remove the very large reads column.  See below.

reads <- c(reads[names(reads)!="tag"],reads$tag) #unpack each element of reads$tag and add it to reads

#add an element indicating whether or not the read came from a gene with no reads mapping to the pen version
genes.zero.map <- pen.count.comparison.1$id[pen.count.comparison.1$count.known>0 & pen.count.comparison.1$count.mapped==0]
reads$gene <- unlist(strsplit(reads$qname,";"))[c(FALSE,TRUE,FALSE,FALSE)]
lapply(reads, head)
reads$pen.zero.map <- reads$gene %in% genes.zero.map

table(reads$flag,reads$pen.zero.map)
table(reads$NH,reads$pen.zero.map) #number of hits

reads.df <- with(reads,data.frame(qname,rname,pos,qwidth,flag,cigar,NH,HI,AS,nM,gene,pen.zero.map,stringsAsFactors=FALSE))
reads.df$gene.lyc <- substr(reads.df$gene,18,38)
  
reads.df$multimap <- reads.df$NH>1

reads.df$pen.gene.length <- pen.gene.length[reads.df$gene]
reads.df$lyc.gene.length <- lyc.gene.length[reads.df$gene]

reads.df$pen.lyc.gene.length.dif <- reads.df$pen.gene.length - reads.df$lyc.gene.length

reads.df$pen.lyc.gene.length.ratio <- reads.df$pen.gene.length / reads.df$lyc.gene.length
```

## Reads plotted by genes hit and mismatches
```{r, fig_height=5,fig_width=8, echo=FALSE}
ggplot(reads.df,aes(x=as.factor(NH),y=nM,group=NH)) + geom_point(stat="sum") + scale_size(breaks=seq(0,1,.1),range=c(1,15)) + xlab("Number of genes hit") + ylab("Number of mismatches")
```


```{r not_used, echo=FALSE, eval=FALSE}
ggplot(reads.df,aes(x=as.factor(NH),y=pen.gene.length,fill=pen.zero.map)) + geom_violin()

ggplot(reads.df,aes(x=as.factor(NH),y=lyc.gene.length,fill=pen.zero.map)) + geom_violin()

ggplot(reads.df,aes(x=as.factor(NH),y=pen.gene.length)) + geom_violin()

ggplot(reads.df,aes(x=as.factor(NH),y=pen.lyc.gene.length.ratio,fill=multimap)) + geom_violin()

ggplot(reads.df,aes(x=pen.zero.map,y=pen.gene.length,fill=multimap)) + geom_boxplot()

ggplot(reads.df,aes(x=pen.zero.map,y=pen.lyc.gene.length.ratio,fill=multimap)) + geom_violin()
```

## Gene length effects

```{r, echo=FALSE,results='hide'}
ggplot(pen.count.comparison.1,aes(x=gene.length.diff.pen.lyc,y=count.ratio.known.mapped)) + geom_point(alpha=0.1) + scale_y_log10() + scale_x_log10(breaks=c(1,10,100,200,300,500,1000))
```


## Gene length effects 2

```{r, echo=FALSE, results='hide'}
ggplot(pen.count.comparison.1,aes(x=gene.length.ratio.pen.lyc,y=count.ratio.known.mapped))  + scale_y_log10() + scale_x_log10(breaks=c(.1,.5,seq(1,2,.2),3,5,10)) + geom_hline(yintercept=1,color="blue") + geom_vline(xintercept=1,color="blue") + geom_point(alpha=.1)
```


## Remove genes
Remove genes with gene length ratio > 1.3 or gene length difference > 300bp
```{r, echo=FALSE, results='hide'}
#reasonable cutoffs might be a gene.length.ratio > 1.3 or a gene length difference of > 300

pen.count.comparison.1.cutoff1.3 <- pen.count.comparison.1[pen.count.comparison.1$gene.length.ratio.pen.lyc < 1.3,]
nrow(pen.count.comparison.1)
nrow(pen.count.comparison.1.cutoff1.3)
with(pen.count.comparison.1.cutoff1.3,cor(count.known,count.mapped))

pen.count.comparison.1.cutoff300 <- pen.count.comparison.1[pen.count.comparison.1$gene.length.diff.pen.lyc < 300,]
nrow(pen.count.comparison.1)
nrow(pen.count.comparison.1.cutoff300)
with(pen.count.comparison.1.cutoff300,cor(count.known,count.mapped))

pen.count.comparison.1.cutoff300.1.3 <- pen.count.comparison.1[pen.count.comparison.1$gene.length.diff.pen.lyc < 300 & pen.count.comparison.1$gene.length.ratio.pen.lyc < 1.3,]
nrow(pen.count.comparison.1)
nrow(pen.count.comparison.1.cutoff300.1.3)
with(pen.count.comparison.1.cutoff300.1.3,cor(count.known,count.mapped))

length.cutoff.plot.data <- as.data.frame(t(sapply(seq(0,max(pen.count.comparison.1$gene.length.diff.pen.lyc),50),function(x) 
  with(
    pen.count.comparison.1[pen.count.comparison.1$gene.length.diff.pen.lyc <= x ,],
    c(cutoff=x,genes=length(count.known),correlation=cor(count.known,count.mapped))))))
length.cutoff.plot.data$type <- "difference"


ratio.cutoff.plot.data <- as.data.frame(t(sapply(seq(1,max(pen.count.comparison.1$gene.length.ratio.pen.lyc),.1),function(x) 
  with(
    pen.count.comparison.1[pen.count.comparison.1$gene.length.ratio.pen.lyc <= x ,],
    c(cutoff=x,genes=length(count.known),correlation=cor(count.known,count.mapped))))))
ratio.cutoff.plot.data$type <- "ratio"

combined.cutoff.plot.data <-rbind(length.cutoff.plot.data,ratio.cutoff.plot.data)

ggplot(combined.cutoff.plot.data,aes(x=genes,y=correlation,color=type)) + geom_line() 

#ggplot(length.cutoff.plot.data,aes(x=genes,y=correlation,label=cutoff)) + geom_line() + geom_text(aes(label=cutoff),size=2.5,vjust=-1,hjust=-.3) 
```

## how many reads map to the wrong gene?

```{r mismapping, echo=FALSE, results='hide'}
lyc.transcript.gr <- import("~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_gene_models.gff3",feature.type="mRNA")
reads.df.map <- na.omit(reads.df)
reads.gr <- with(reads.df.map,GRanges(seqnames=rname,
                    ranges = IRanges(start=pos,
                                     width = qwidth, #note that this is not precisely correct because of introns,etc
                                     names=qname)))
hits <- findOverlaps(reads.gr,lyc.transcript.gr,ignore.strand=TRUE)
sum(reads.df.map$gene.lyc[queryHits(hits)] != lyc.transcript.gr$Name[subjectHits(hits)]) / length(hits)
reads.df.map.single <- reads.df.map[reads.df.map$NH==1,]
reads.gr.single <- with(reads.df.map.single,GRanges(seqnames=rname,
                    ranges = IRanges(start=pos,
                                     width = qwidth, #note that this is not precisely correct because of introns,etc
                                     names=qname)))
hits.single <- findOverlaps(reads.gr.single,lyc.transcript.gr,ignore.strand=TRUE)
sum(reads.df.map.single$gene.lyc[queryHits(hits.single)] != lyc.transcript.gr$Name[subjectHits(hits.single)]) / length(hits.single)

reads.df.map.single.overlap <- reads.df.map.single[queryHits(hits.single),] #only keep reads that overlap a transcript

reads.df.map.single.overlap$gene.mapped.to <- lyc.transcript.gr$Name[subjectHits(hits.single)]

#remove chromosome zero

reads.df.map.single.overlap <- reads.df.map.single.overlap[!grepl("Solyc00g",paste(reads.df.map.single.overlap$gene.lyc,reads.df.map.single.overlap$gene.mapped.to)),] #not very different

with(reads.df.map.single.overlap,sum(gene.lyc!=gene.mapped.to)/length(gene.lyc))

#are reads represented more than once?
length(unique(reads.df.map.single.overlap$qname))/nrow(reads.df.map.single.overlap)
#yes.  So reads are overlapping with multiple genes.  Presumably this is due to overlaping genes in the annotation.

reads.df.map.single.overlap$chrom.lyc <- substr(reads.df.map.single.overlap$gene.lyc,6,8)
reads.df.map.single.overlap$chrom.mapped.to <- substr(reads.df.map.single.overlap$gene.mapped.to,6,8)


reads.df.map.single.overlap$mismap <- reads.df.map.single.overlap$gene.lyc != reads.df.map.single.overlap$gene.mapped.to
head(reads.df.map.single.overlap,50)
head(reads.df.map.single.overlap[reads.df.map.single.overlap$mismap,c("gene.lyc","gene.mapped.to")],50)
#yes the overlapping annotaiton seems to explain some of it.  Can check more
reads.df.map.single.overlap <- within(reads.df.map.single.overlap, mapnear <- 
                                        (abs(as.numeric(substr(gene.lyc,9,14)) - as.numeric(substr(gene.mapped.to,9,14))) < 40) & 
                                        chrom.lyc == chrom.mapped.to)
head(reads.df.map.single.overlap[reads.df.map.single.overlap$mismap,c("gene.lyc","gene.mapped.to","mapnear")],100)
with(reads.df.map.single.overlap,sum(mapnear & mismap) / sum(mismap))

#so if we get rid of the "mapnear" mismaps how many mismaps are left?
sum(reads.df.map.single.overlap$mismap[!reads.df.map.single.overlap$mapnear]) / nrow(reads.df.map.single.overlap)

#save.image("rnaseqSim.Rdata")
save(list=grep("reads",ls(),invert = TRUE,value=T),file="rnaseqSim_no_read_data.Rdata")
```

## mismapping

Total mismapping
```{r mismap_summary_total}
with(reads.df.map.single.overlap,sum(mismap) / length(mismap))
```

Of mismaps, what proportion map near to the correct gene:
```{r mismap_summary_near}
with(reads.df.map.single.overlap,sum(mapnear & mismap) / sum(mismap))
```

Proportion reads mapped to wrong gene (distant):
```{r mismap_distant_summary}
sum(reads.df.map.single.overlap$mismap[!reads.df.map.single.overlap$mapnear]) / nrow(reads.df.map.single.overlap)
```


## why mismapping?
Investigate by looking at where S.pen genes map on S.lyc chromosomes.

Are the S. pen "Orthlogs" really mapping to their cognate S.lyc gene?

Use BLAT to map S. pen predicted cDNAs to S. lyc genome.

```{r BLAT_install, eval=FALSE, engine='bash', echo=FALSE}
brew install blat
```

```{r run_BLAT, engine='bash', eval=FALSE, echo=FALSE}
blat ~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/S_lycopersicum_chromosomes.2.50.fa -q=rna -t=dna -minMatch=4 ~/Sequences/ref_genomes/S.pen/Spenn-v2-cds-annot_orthlogs_only.fa -maxIntron=20000 penCDS_to_lycGENME.psl
#setting minMatch to 4 reduces number of overlaps from ~6300 to 3300
```

## Map _real_ reads as comparision
```{r map_real,eval=FALSE, echo=FALSE}
RunStar(fasta = "/Volumes/temp-o-matic/temp_SolRAID_restore/Solexa_runs_Data/Filtered_fastq_by_seedling_exp/merged_files/PEN.seedlings.fq",
        prefix = "STAR_1",
        dir = "spen_real",
        n=12,
        param.file = "../STAR.params.whitney.1")
```


Now look in IGV (Note: Need to use IGVtools to sort and index the .psl file)

```{r}
head(reads.df.map.single.overlap[reads.df.map.single.overlap$mismap,c("qname","gene.lyc","gene.mapped.to","mapnear")],100)
sort(table(reads.df.map.single.overlap$gene.lyc[reads.df.map.single.overlap$mismap]))
```

## 5 examples of genes with mismapping

* Solyc02g090930.2.1 (12): Tandem Repeat with Solyc02g090940.2.1
* Solyc04g072480.2.1 (30): Nothing obviously strange
* Solyc03g051930.2.1 (70): PEN gene spans two LYC genes
* Solyc02g079850.2.1 (150): PEN gene spans two LYC genes
* Solyc01g110960.2.1 (497): Much Confusion

## 5 examples of genes with zero mapping

```{r, echo=FALSE}
pen.count.comparison.1.cutoff300.1.3[pen.count.comparison.1.cutoff300.1.3$count.ratio==Inf,c("lyc.id","count.known","gene.length.ratio.pen.lyc")]
```

* Solyc01g010050.2: Two overlapping LYC transcripts (note this is fixed when using FeatureCounts from subread)
* Solyc01g060020.2: Multiple overlapping LYC transcripts
* Solyc05g023780.1: Repetitive region
* Solyc08g015710.1: Very small region of homology
* Solyc11g056540.1: BLAT did not find a match

## How to deal with this?

Many of these issues could be dealt with by

1. Eliminating genes with overlapping LYC to LYC or PEN to LYC transcripts. 
2. Using the BLAT results to eliminate transcripts with poor homology.

```{r, echo=FALSE}
lyc.lyc.overlaps <- findOverlaps(lyc.transcript.gr,lyc.transcript.gr) #all overlaps including self on self
lyc.lyc.overlaps <- lyc.lyc.overlaps[queryHits(lyc.lyc.overlaps)!=subjectHits(lyc.lyc.overlaps),] #limit to non-self overlaps
lyc.lyc.overlaps <- substr(unique(mcols(lyc.transcript.gr)[queryHits(lyc.lyc.overlaps),"Name"]),1,16)

pen.transcript.gr <- PSL2Granges(file="penCDS_to_lycGENME.psl")
pen.pen.overlaps <- findOverlaps(pen.transcript.gr,pen.transcript.gr) #all overlaps including self on self

#need additional step to limit to non-self overlaps because BLAT returns multiple hits in the same region.  Make sure that the overlap is with the same gene
pen.pen.overlaps <- pen.pen.overlaps[names(pen.transcript.gr)[queryHits(pen.pen.overlaps)]!=names(pen.transcript.gr)[subjectHits(pen.pen.overlaps)]] 

pen.pen.overlaps <- unique(mcols(pen.transcript.gr)[queryHits(pen.pen.overlaps),"lyc.ID"]) 
```

## Original
```{r, echo=FALSE}
pen.count.comparison.1$flag <- "none"
pen.count.comparison.1 <- within(pen.count.comparison.1,{
                                 flag[pen.count.comparison.1$lyc.id %in% lyc.lyc.overlaps] <- "lyc.lyc.overlap"
                                 flag[pen.count.comparison.1$lyc.id %in% pen.pen.overlaps] <- "pen.pen.overlap"
                                 }
                                 )
with(pen.count.comparison.1,cor(count.known,count.mapped))
```

## With bad annotations removed
Genes where more than one _S.lyc_ or more than one _S.pen_ annotation overlap are removed.
```{r}
with(pen.count.comparison.1[pen.count.comparison.1$flag=="none",],cor(count.known,count.mapped))
```
Pretty good!

# Mapping to cDNA reference with kallisto

[Kallisto](https://pachterlab.github.io/kallisto/about.html) is a read quantification software that works without aligning.  I would like to see how it performs in this context.

## installation
mac command line
```{r, eval=FALSE, engine='bash'}
brew install kallisto
```

## build index
only needs to be done once:
```{r, eval=FALSE, engine='bash'}
kallisto index -i ITAG2.4._cds.pen.orthlogsonly.31.kai ~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_cds.pen.orthologs.only.fasta
```
But I wonder if different kmers would give different results

## For kallisto fasta needs to be converted to fastq
Download [converter](https://code.google.com/archive/p/fasta-to-fastq/downloads)
```{r, engine='bash',eval=FALSE}
gzcat  spen_sim_2/sample_01_renamed.fasta.gz | perl ~/bin/fasta_to_fastq.pl  - | gzip > spen_sim_2/sample_01_renamed.fastq.gz
gzcat  slyc_sim_2/sample_01_renamed.fasta.gz | perl ~/bin/fasta_to_fastq.pl  - | gzip > slyc_sim_2/sample_01_renamed.fastq.gz
```

## run kallisto
```{r run_kallisto, eval=TRUE}
RunKallisto(fasta = "spen_sim_2/sample_01_renamed.fastq.gz", index = "ITAG2.4._cds.pen.orthlogsonly.31.kai", dir = "spen_sim_2/kallisto31" )
```

## Load in mapped counts
```{r get_mapped_counts_kallisto }
pen.mapped.counts <- GetMappedCounts(dir = "spen_sim_2/kallisto", type="kallisto-transcripts")
```

## _S. pennellii_
Compare known to mapped counts  
```{r compare_spen1_kallisto_default, echo=FALSE, results='hide', fig.width=8, fig.height=5}
pen.count.comparison.1 <- CompareCounts(pen.known.counts, pen.mapped.counts, chrom.separate=FALSE, title = "S. pen. kallisto mapped to cDNA.  Default parameters.  Kallisto counting")  
```

## Remove overlapping genes and plot
Genes with more than one _S.lyc_ or more than one _S.pen_ annotation overlap are removed.
```{r remove_bad_kallisto_default, echo=FALSE}
pen.count.comparison.1$flag <- "none"
pen.count.comparison.1 <- within(pen.count.comparison.1,{
                                 flag[pen.count.comparison.1$lyc.id %in% lyc.lyc.overlaps] <- "lyc.lyc.overlap"
                                 flag[pen.count.comparison.1$lyc.id %in% pen.pen.overlaps] <- "pen.pen.overlap"
                                 }
                                 )
```

```{r compare_spen1_kallisto_default_bad_removed, echo=FALSE, results='hide', fig.width=8, fig.height=5}
source("Rnaseq_sim_helper_functions.R")
CompareCounts(pen.count.comparison.1[pen.count.comparison.1$flag=="none",], chrom.separate = FALSE, title = "S. pen. kallisto mapped to cDNA.  Default parameters.  Kallisto counting.  Overlapping genes removed.")  
```
Pretty good!

# Kallisto with 21nt kmers

## build index
only needs to be done once:
```{r, eval=FALSE, engine='bash'}
kallisto index -k 21 -i ITAG2.4._cds.pen.orthlogsonly.21.kai ~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_cds.pen.orthologs.only.fasta
```

## run kallisto
```{r run_kallisto_21, eval=TRUE}
RunKallisto(fasta = "spen_sim_2/sample_01_renamed.fastq.gz", index = "ITAG2.4._cds.pen.orthlogsonly.21.kai", dir = "spen_sim_2/kallisto21" )
```

## Load in mapped counts
```{r get_mapped_counts_kallisto21 }
pen.mapped.counts <- GetMappedCounts(dir = "spen_sim_2/kallisto21", type="kallisto-transcripts")
```

## _S. pennellii_
Compare known to mapped counts  
```{r compare_spen1_kallisto21, echo=FALSE, results='hide', fig.width=8, fig.height=5}
pen.count.comparison.1 <- CompareCounts(pen.known.counts, pen.mapped.counts, chrom.separate=FALSE, title = "S. pen. kallisto mapped to cDNA. 21nt kmer.  Kallisto counting")  
```

## Remove overlapping genes and plot
Genes with more than one _S.lyc_ or more than one _S.pen_ annotation overlap are removed.
```{r remove_bad_kallisto_21, echo=FALSE}
pen.count.comparison.1$flag <- "none"
pen.count.comparison.1 <- within(pen.count.comparison.1,{
                                 flag[pen.count.comparison.1$lyc.id %in% lyc.lyc.overlaps] <- "lyc.lyc.overlap"
                                 flag[pen.count.comparison.1$lyc.id %in% pen.pen.overlaps] <- "pen.pen.overlap"
                                 }
                                 )
```

```{r compare_spen1_kallisto21_bad_removed, echo=FALSE, results='hide', fig.width=8, fig.height=5}
CompareCounts(pen.count.comparison.1[pen.count.comparison.1$flag=="none",], chrom.separate = FALSE, title = "S. pen. kallisto mapped to cDNA.  21nt kmer.  Kallisto counting.  Overlapping genes removed.")  
```

Pretty good!

# Optimize Kallisto kmer

## Idea

Lowering the kallisto kmer improved the correlation between known and mapped counts

What is the best kmer?

In this section I will try a bunch of kmers

## Build kalliso indexes for different kmers.

```{r kallisto_kmer_indices, eval=FALSE} 
#only run once...it will be slow!
library(snowfall)
kmers <- c(seq(11,19,2),seq(23,29,2)) #21 and 31 already done
sfInit(cpu=min(kmers,12),parallel = TRUE)
sfClusterApply(kmers, function(k) {
  index.name <- paste("ITAG2.4._cds.pen.orthlogsonly.",k,".kai",sep="")
  system(paste("kallisto index -k", k,
               " -i", index.name, 
               "~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_cds.pen.orthologs.only.fasta"))})
sfStop()
```

## Run Kallisto on the different indicies

```{r kallisto_kmer_run}
library(snowfall)
indicies <- dir(pattern="[0-9]\\.kai")
sfInit(cpu=2,parallel = TRUE)
sfSource("Rnaseq_sim_helper_functions.R")
sfExport("pen.known.counts","lyc.lyc.overlaps","pen.pen.overlaps","pen.gene.length","lyc.gene.length")
results.combined <- sfLapply(indicies,function(i) {
  kmer <- sub("ITAG2\\.4\\._cds\\.pen\\.orthlogsonly\\.([0-9]{2})\\.kai","\\1",i)
  dir.out <- paste("spen_sim_2/kallisto",kmer,sep="")
  results <- list()
  results$kmer <- as.numeric(kmer)
  results$time <- system.time(RunKallisto(fasta = "spen_sim_2/sample_01_renamed.fastq.gz", 
              index = i, 
              dir = dir.out))
  pen.mapped.counts <- GetMappedCounts(dir = dir.out, type="kallisto-transcripts")
  pen.count.comparison <- CompareCounts(pen.known.counts,pen.mapped.counts,plot = FALSE,correlation = FALSE)
  pen.count.comparison$flag <- "none"
  pen.count.comparison <- within(pen.count.comparison,{
                                 flag[pen.count.comparison$lyc.id %in% lyc.lyc.overlaps] <- "lyc.lyc.overlap"
                                 flag[pen.count.comparison$lyc.id %in% pen.pen.overlaps] <- "pen.pen.overlap"
                                 }
                                 )
  results$corr.all <- with(pen.count.comparison,c(cor(count.known, count.mapped),cor(count.known,count.mapped,method="spearman")))
  results$corr.bad.removed <- with(pen.count.comparison[pen.count.comparison$flag=="none",],
                                   c(cor(count.known, count.mapped),cor(count.known,count.mapped,method="spearman")))
  return(results)
})
sfStop()
```

## kalliso kmer effects
```{r kallisto_kmer_summarize, echo=FALSE, fig.width=4, fig.height=6}
plot(x=unlist(lapply(results.combined,function(x) x$kmer)),y=unlist(lapply(results.combined, function(x) x$time["elapsed"])),type="b",ylab="time (sec)",xlab="kmer",main="kallisto time for different kmer values")

matplot(x=unlist(lapply(results.combined,function(x) x$kmer)),
        y=ldply(results.combined, function(x) x$corr.all),type="b",pch=1
        ,ylab="Correlation",xlab="kmer",main="All genes")
legend("bottom",legend=c("Pearson","Spearman"),lty=1:2,col=1:2,bty="n")

matplot(x=unlist(lapply(results.combined,function(x) x$kmer)),
        y=ldply(results.combined, function(x) x$corr.bad.removed),type="b",pch=1
        ,ylab="Correlation",xlab="kmer",main="'Good' genes")
legend("bottom",legend=c("Pearson","Spearman"),lty=1:2,col=1:2,bty="n")
```

So, kmer=19 is the best

# Mapping to genomic with subread

## Installation
Download [subread](https://sourceforge.net/projects/subread)

untar and unzip it, move binaries to /usr/local/bin (or make symbolic links)

```{r install_subread, eval=FALSE}
# in R
source("https://bioconductor.org/biocLite.R")
biocLite("Rsubread")```

## Build Indexes

```{r index_subread, eval=F}
library(Rsubread)
buildindex("Slyc_Chromo2.5_subread_index","/Users/jmaloof/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/S_lycopersicum_chromosomes.2.50.fa") #note does not do tilde expansion
# 5.5 minutes
```

## Map

```{r map_subread, eval=F}
system.time(align("Slyc_Chromo2.5_subread_index",
                  "spen_sim_2/sample_01_renamed.fastq.gz", 
                  output_file=paste("spen_sim_2/sample_01_renamed.fastq.gz","subread","default","BAM",sep="."),
                  nthreads = 2))
```
On Royce, with 2 threads:

user    | system | elapsed 
--------|--------|--------   
310.463 | 32.216 | 211.111 

## Get Counts

```{r get_subread_counts}
pen.mapped.counts <- GetMappedCounts(dir="spen_sim_2/",type = "featureCounts",bam = "sample_01_renamed.fastq.gz.subread.default.BAM")
```

## Compare counts

Compare known to mapped counts  
```{r compare_spen1_subread, echo=FALSE, results='hide', fig.width=8, fig.height=5}
pen.count.comparison.1 <- CompareCounts(pen.known.counts, pen.mapped.counts, chrom.separate=FALSE, title = "S. pen. subread mapped to genomic. FeatureCounts counting")  
```

## Remove overlapping genes and compare
Genes with more than one _S.lyc_ or more than one _S.pen_ annotation overlap are removed.
```{r remove_bad_subread, echo=FALSE}
pen.count.comparison.1$flag <- "none"
pen.count.comparison.1 <- within(pen.count.comparison.1,{
                                 flag[pen.count.comparison.1$lyc.id %in% lyc.lyc.overlaps] <- "lyc.lyc.overlap"
                                 flag[pen.count.comparison.1$lyc.id %in% pen.pen.overlaps] <- "pen.pen.overlap"
                                 }
                                 )
```

```{r compare_spen1_subread_bad_removed, echo=FALSE, results='hide', fig.width=8, fig.height=5}
CompareCounts(pen.count.comparison.1[pen.count.comparison.1$flag=="none",], chrom.separate = FALSE, title = "S. pen. subread mapped to genomic. FeatureCounts counting. Overlapping genes removed.")  
```

## map with subread allowing more mismatches (5)

```{r map_subread_MM5, eval=F}
system.time(align("Slyc_Chromo2.5_subread_index",
                  "spen_sim_2/sample_01_renamed.fastq.gz", 
                  output_file=paste("spen_sim_2/sample_01_renamed.fastq.gz","subread","5MM","BAM",sep="."),
                  nthreads = 2,
                  maxMismatches = 5))
```
On Royce, with 2 threads:

user    | system | elapsed 
--------|--------|--------   
315.772 | 29.543 | 221.174 
```{r get_subread_counts_MM5}
pen.mapped.counts <- GetMappedCounts(dir="spen_sim_2/",type = "featureCounts",bam = "sample_01_renamed.fastq.gz.subread.5MM.BAM")
```

## Compare counts

Compare known to mapped counts  
```{r compare_spen1_subread_MM5, echo=FALSE, results='hide', fig.width=8, fig.height=5}
pen.count.comparison.1 <- CompareCounts(pen.known.counts, pen.mapped.counts, chrom.separate=FALSE, title = "S. pen. subread mapped to genomic; 5 mismatches. FeatureCounts counting")  
```

## Remove overlapping genes and compare
Genes with more than one _S.lyc_ or more than one _S.pen_ annotation overlap are removed.
```{r remove_bad_subread_MM5, echo=FALSE}
pen.count.comparison.1$flag <- "none"
pen.count.comparison.1 <- within(pen.count.comparison.1,{
                                 flag[pen.count.comparison.1$lyc.id %in% lyc.lyc.overlaps] <- "lyc.lyc.overlap"
                                 flag[pen.count.comparison.1$lyc.id %in% pen.pen.overlaps] <- "pen.pen.overlap"
                                 }
                                 )
```

```{r compare_spen1_subread_bad_removed_MM5, echo=FALSE, results='hide', fig.width=8, fig.height=5}
CompareCounts(pen.count.comparison.1[pen.count.comparison.1$flag=="none",], chrom.separate = FALSE, title = "S. pen. subread mapped to genomic. FeatureCounts countingl 5 mismatches. Overlapping genes removed.")  
```

# Map with bowtie2

## Installation

```{r install_bowtie2_mac, eval=FALSE}
brew install bowtie2
```

## Make bowtie index

```{r bowtie_slyc_index, eval=FALSE}
bowtie2-build --threads 2 ~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/S_lycopersicum_chromosomes.2.50.fa ~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/S_lycopersicum_chromosomes.2.50.fa
```

## Map
```{r bowtie_map_spen, eval=FALSE}
system.time(RunBowtie2(fastq = "sample_01_renamed.fastq.gz",
           index = "~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/S_lycopersicum_chromosomes.2.50.fa",
           dir = "spen_sim_2",
           prefix="bowtie2"))
```

Royce with 2 threads
user    | system | elapsed 
--------|--------|--------   
622.348 | 13.297 | 300.922

## Get counts
```{r get_bowtie2_counts_spen}
pen.mapped.counts <- GetMappedCounts(dir="spen_sim_2/",type = "featureCounts",bam = "bowtie2.bam")
```

## Compare counts

Compare known to mapped counts  
```{r compare_spen1_bowtie2, echo=FALSE, results='hide', fig.width=8, fig.height=5}
pen.count.comparison.1 <- CompareCounts(pen.known.counts, pen.mapped.counts, chrom.separate=FALSE, title = "S. pen. bowtie2 mapped to genomic. FeatureCounts counting")  
```

## Remove overlapping genes and compare
Genes with more than one _S.lyc_ or more than one _S.pen_ annotation overlap are removed.
```{r remove_bad_bowtie2, echo=FALSE}
pen.count.comparison.1$flag <- "none"
pen.count.comparison.1 <- within(pen.count.comparison.1,{
                                 flag[pen.count.comparison.1$lyc.id %in% lyc.lyc.overlaps] <- "lyc.lyc.overlap"
                                 flag[pen.count.comparison.1$lyc.id %in% pen.pen.overlaps] <- "pen.pen.overlap"
                                 }
                                 )
```

```{r compare_spen1_bowtie2_bad_removed, echo=FALSE, results='hide', fig.width=8, fig.height=5}
CompareCounts(pen.count.comparison.1[pen.count.comparison.1$flag=="none",], chrom.separate = FALSE, title = "S. pen. bowtie2 mapped to genomic. FeatureCounts counting. Overlapping genes removed.")  
```

# Map with stampy

## Install stampy

Note: only runs on linux.  Needs python 2.7

## Build index
```{r, eval=FALSE}
stampy.py -G SL2.5 ~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/S_lycopersicum_chromosomes.2.50.fa
stampy.py -g SL2.5 -H SL2.5
```

## Map
```{r,eval=FALSE}
system.time(RunStampy("sample_01_renamed.fasta.gz",index = "SL2.5",dir = "spen_sim_2", prefix="stampy",threads=2))
```

Whitney with two threads
user    | system | elapsed 
--------|--------|--------   
9385.250| 96.822 |4424.086

OUCH!  Could be because of disk speed.  Nope; tested on local disk and same result.

Another option is to pre-run BWA

## Get counts
```{r get_stampy_counts_spen}
pen.mapped.counts <- GetMappedCounts(dir="spen_sim_2/",type = "featureCounts",bam = "stampy.bam")
```

## Compare counts

Compare known to mapped counts  
```{r compare_spen1_stampy, echo=FALSE, results='hide', fig.width=8, fig.height=5}
pen.count.comparison.1 <- CompareCounts(pen.known.counts, pen.mapped.counts, chrom.separate=FALSE, title = "S. pen. stampy mapped to genomic. FeatureCounts counting")  
```

## Remove overlapping genes and compare
Genes with more than one _S.lyc_ or more than one _S.pen_ annotation overlap are removed.
```{r remove_bad_stampy, echo=FALSE}
pen.count.comparison.1$flag <- "none"
pen.count.comparison.1 <- within(pen.count.comparison.1,{
                                 flag[pen.count.comparison.1$lyc.id %in% lyc.lyc.overlaps] <- "lyc.lyc.overlap"
                                 flag[pen.count.comparison.1$lyc.id %in% pen.pen.overlaps] <- "pen.pen.overlap"
                                 }
                                 )
```

```{r compare_spen1_stampy_bad_removed, echo=FALSE, results='hide', fig.width=8, fig.height=5}
CompareCounts(pen.count.comparison.1[pen.count.comparison.1$flag=="none",], chrom.separate = FALSE, title = "S. pen. stampy mapped to genomic. FeatureCounts counting. Overlapping genes removed.")  
```

# Map with BWA

This is mapping against cDNAs rather then to genomic, so comparable to Kallisto

## Build index
```{r, eval=FALSE, engine='bash'}
 bwa index ~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_cds.pen.orthologs.only.fasta
```

## Map
```{r, eval=FALSE}
system.time(RunBWAaln("sample_01_renamed.fasta.gz",
          index = "~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_cds.pen.orthologs.only.fasta",
          dir = "spen_sim_2", 
          prefix="bwa",
          threads=2))
```
Royce with two threads
user    | system | elapsed 
--------|--------|--------   
659.294 | 10.215 | 424.427 

## Get counts
```{r get_bwa_counts_spen}
pen.mapped.counts <- GetMappedCounts(dir="spen_sim_2/",type = "transcripts",bam = "bwa.bam")
```

## Compare counts

Compare known to mapped counts  
```{r compare_spen1_bwa, echo=FALSE, results='hide', fig.width=8, fig.height=5}
pen.count.comparison.1 <- CompareCounts(pen.known.counts, pen.mapped.counts, chrom.separate=FALSE, title = "S. pen. bwa mapped to CDS. samtools idxstats counting")  
```

## Remove overlapping genes and compare
Genes with more than one _S.lyc_ or more than one _S.pen_ annotation overlap are removed.
```{r remove_bad_bwa, echo=FALSE}
pen.count.comparison.1$flag <- "none"
pen.count.comparison.1 <- within(pen.count.comparison.1,{
                                 flag[pen.count.comparison.1$lyc.id %in% lyc.lyc.overlaps] <- "lyc.lyc.overlap"
                                 flag[pen.count.comparison.1$lyc.id %in% pen.pen.overlaps] <- "pen.pen.overlap"
                                 }
                                 )
```

```{r compare_spen1_bwa_bad_removed, echo=FALSE, results='hide', fig.width=8, fig.height=5}
CompareCounts(pen.count.comparison.1[pen.count.comparison.1$flag=="none",], chrom.separate = FALSE, title = "S. pen. bwa mapped to CDS. samtools idxstats counting. Overlapping genes removed.")  
```
