---
title: "S. pennellii RNAseq simulations"
author: "Julin Maloof"
date: "February 18, 2016"
output:
  revealjs::revealjs_presentation:
    reveal_options:
      width: 1200
      height: 800
---

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(cache=TRUE)
opts_chunk$set(warnings=FALSE)
opts_chunk$set(messages=FALSE)
```


# Introduction

## Overall Question

When mapping RNAseq reads from a heterologous species to a reference genome, what is the best way to perform the mapping?

For example:

  > - We have a tomato reference genome
  > - We want to do RNAseq on a variety of wild relatives of tomato for which we have no genome

## Strategy: simulation

> * Use _S. pennellii_ and _S. lycopersium_.  Both are sequenced.  
> * Simulate RNASeq reads from _S. pennellii_ and map to _S. lycopersicum_.
> * Compare actual (simulated) counts to the number of counts that map.


> * Can compare different aligners:
      * stampy
      * subread
      * star
      * bowtie

> * And different parameters with those aligners.

# Preliminaries

## Install Polyester

Use the [Polyester package](http://bioconductor.org/packages/release/bioc/vignettes/polyester/inst/doc/polyester.html)  to simulate RNAseq reads.  Also see the [Polyester paper.](http://bioinformatics.oxfordjournals.org/content/31/17/2778)

Installation.  Only needs to be run once per computer.
```{r install_polyester, eval=FALSE}
source("http://bioconductor.org/biocLite.R")
biocLite("polyester")
```

## Install STAR (only needs to be done once)
(NOTE THAT VERSION 2.5 IS NEEDED AND THIS IS NOT CURRENTLY IN HOMEBREW)
```{r install_STAR, eval=FALSE, engine='bash'}
brew install rna-star
brew install gcc5 
```

## load libraries and helper scripts
```{r, cache=FALSE}
library(polyester)
library(Biostrings)
library(ggplot2)
library(Rsamtools)
library(rtracklayer)
library(Rsubread)
library(R.utils)
setwd("~/Documents/Lab Notebook support/2015/rnaseq_simulations")
source("Rnaseq_sim_helper_functions.R")
```

## Simluate reads (simple version)
Load Spen and Slyc transcripts  
Spen CDS fasta can be obtained from [SGN](ftp://ftp.solgenomics.net/genomes/Solanum_pennellii/annotations/)
slyc fasta is also from [SGN](ftp://ftp.sgn.cornell.edu/genomes/Solanum_lycopersicum/annotation/ITAG2.4_release/)
```{r load_Spen, eval=TRUE}
pen.transcripts <-  readDNAStringSet("~/Sequences/ref_genomes/S.pen/Spenn-v2-cds-annot.fa")
head(pen.transcripts)
names(pen.transcripts[1:10])
lyc.transcripts <- readDNAStringSet("~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_cds.fasta")
head(lyc.transcripts)
names(lyc.transcripts)[1:10]
```

## Reformat names to get rid of description and add Slyc reference
```{r reformat_gene_names, eval=TRUE}
orthologs <- read.delim("Ortho_v2.txt",header=FALSE) #From Tony Bolger
head(orthologs)
names(orthologs) <- c("PEN","LYC")
orthologs$PEN <- sub("t","",orthologs$PEN)
orthologs$PEN.LYC <- paste(orthologs$PEN,orthologs$LYC,sep="_")
names(pen.transcripts) <- substr(names(pen.transcripts),1,16)
names(pen.transcripts) <- ifelse(!is.na(match(names(pen.transcripts),orthologs$PEN)),
                                 orthologs$PEN.LYC[match(names(pen.transcripts),orthologs$PEN)],
                                 names(pen.transcripts))
pen.transcripts

names(lyc.transcripts) <- substr(names(lyc.transcripts),1,18)
names(lyc.transcripts) <- ifelse(!is.na(match(names(lyc.transcripts),orthologs$LYC)),
                                 orthologs$PEN.LYC[match(names(lyc.transcripts),orthologs$LYC)],
                                 names(lyc.transcripts))
pen.gene.length <- as.integer(nchar(pen.transcripts))
names(pen.gene.length) <- names(pen.transcripts)
lyc.gene.length <- as.integer(nchar(lyc.transcripts))
names(lyc.gene.length) <- names(lyc.transcripts)
```

## Limit ourselves to genes where orthology is clear:
```{r reduce_data, eval=FALSE}
pen.transcripts.small <- pen.transcripts[nchar(names(pen.transcripts))>16]
writeXStringSet(pen.transcripts.small,file="~/Sequences/ref_genomes/S.pen/Spenn-v2-cds-annot_orthlogs_only.fa")
lyc.transcripts.small <- lyc.transcripts[nchar(names(lyc.transcripts)) > 18]
writeXStringSet(lyc.transcripts.small,file="~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_cds.pen.orthologs.only.fasta")
```

## Simulate PEN RNAseq reads
```{r simulate_pen_1, eval=FALSE}
#3 minutes for 1M reads
#15 minutes for 5M reads
system.time(
  simulate_experiment(fasta="~/Sequences/ref_genomes/S.pen/Spenn-v2-cds-annot_orthlogs_only.fa",
                      outdir="spen_sim_1",
                      num_reps=1,
                      readlen=45,
                      #line below gives ~ 5M reads, scaled by transcript length
                      reads_per_transcript = round(width(pen.transcripts.small) * 
                                                     5e6/ sum(width(pen.transcripts.small) )),
                      paired=FALSE,
                      error_model="illumina5",
                      bias="rnaf"
  )
)
system("sed 's!/!;!' spen_sim_1/sample_01.fasta > spen_sim_1/sample_01_renamed.fasta") #this allows original gene_names to be kept
system("rm spen_sim_1/sample_01.fasta")
system("gzip spen_sim_1/sample_01_renamed.fasta")
```

## Simulate LYC RNAseq reads
```{r simulate_lyc_1, eval=FALSE}
system.time(
  simulate_experiment(fasta="~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_cds.pen.orthologs.only.fasta",
                      outdir="slyc_sim_1",
                      num_reps=1,
                      readlen=45,
                      #line below gives ~ 5M reads, scaled by transcript length
                      reads_per_transcript = round(width(lyc.transcripts.small) * 
                                                     5e6/ sum(width(pen.transcripts.small) )),
                      paired=FALSE,
                      error_model="illumina5",
                      bias="rnaf"
  )
)
system("sed 's!/!;!' slyc_sim_1/sample_01.fasta > slyc_sim_1/sample_01_renamed.fasta") #this allows original gene_names to be kept
system("rm slyc_sim_1/sample_01.fasta")
system("gzip slyc_sim_1/sample_01_renamed.fasta")
```

## calculate known counts

Use external python script
```{r known_counts}
pen.known.counts <- read.table(pipe("./CountGene.py spen_sim_1/sample_01_renamed.fasta.gz"),col.names=c("id","count"),stringsAsFactors = FALSE)
pen.known.counts$lyc.id <- substr(pen.known.counts$id,18,33)
head(pen.known.counts)

lyc.known.counts <- read.table(pipe("./CountGene.py slyc_sim_1/sample_01_renamed.fasta.gz"),col.names=c("id","count"),stringsAsFactors = FALSE)
lyc.known.counts$lyc.id <- substr(lyc.known.counts$id,18,33)
head(lyc.known.counts)
```

# Map with star

## Create genome file
Only needs to be done once  
This is a shell command  
Takes about 25 minutes  
```{r create_genome_file, eval=FALSE, engine='bash'}
gffread -T ITAG2.4_gene_models.gff3 -o ITAG2.4_gene_models.gtf
STAR --runThreadN 6 --runMode genomeGenerate --genomeDir ~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/STAR_genome --genomeFastaFiles ~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/S_lycopersicum_chromosomes.2.50.fa --sjdbGTFfile ~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_gene_models.gtf
```

## Create parameters files 
```{r STAR_params_1_whitney, eval=FALSE, engine='bash'}
cat > STAR.params.whitney.1
genomeDir /Network/Servers/avalanche.plb.ucdavis.edu/Volumes/Mammoth/Users/jmaloof/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/STAR_genome
outSAMtype BAM SortedByCoordinate
outSAMunmapped Within
quantMode GeneCounts
```

```{r STAR_params_1_royce, eval=FALSE, engine='bash', include=FALSE}
cat > STAR.params.royce.1
genomeDir /Users/jmaloof/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/STAR_genome
outSAMtype BAM SortedByCoordinate
outSAMunmapped Within
quantMode GeneCounts
```

## Run it!
```{r RunStar_1, eval=FALSE}
RunStar(fasta="sample_01_renamed.fasta.gz",prefix = "STAR_1",dir="spen_sim_1",n=2)
RunStar(fasta="sample_01_renamed.fasta.gz",prefix = "STAR_1",dir="slyc_sim_1",n=2)
```
__note__ I needed to use STAR2.5 for this to work.

# Evaluate results from STAR

## We want to do:

* correlation between known counts and found counts
* how many reads map to the wrong gene?
* how many reads do not map?
* are the splice junctions correct?

## Load in mapped counts
```{r get_mapped_counts }
#using the STAR built-in counter
pen.mapped.counts.STAR <- GetMappedCounts(prefix = "STAR_1", dir = "spen_sim_1")
lyc.mapped.counts.STAR <- GetMappedCounts(prefix = "STAR_1", dir = "slyc_sim_1")
#using featureCounts from Rsubread
pen.mapped.counts <- GetMappedCounts(prefix = "STAR_1", dir = "spen_sim_1", type="STAR-featureCounts")
lyc.mapped.counts <- GetMappedCounts(prefix = "STAR_1", dir = "slyc_sim_1", type="STAR-featureCounts")
```

## _S. pennellii_
Compare known to mapped counts  
```{r compare_spen1, echo=FALSE, results='hide', fig.width=8, fig.height=5}
# pen.count.comparison.1.STAR <- CompareCounts(pen.known.counts, pen.mapped.counts.STAR, title = "S. pen.  STAR mapped.  Default parameters")
pen.count.comparison.1 <- CompareCounts(pen.known.counts, pen.mapped.counts, chrom.separate=FALSE, title = "S. pen.  STAR mapped.  Default parameters.  FeatureCounts counting")
```

For many genes this is pretty good, but for some it is pretty poor.  Is this due to S. pen?

## _S. lycopersicum_
Compare known to mapped counts  
```{r compare_slyc1, echo=FALSE, results='hide', fig.width=8, fig.height=5}
# lyc.count.comparison.1.STAR <- CompareCounts(lyc.known.counts, lyc.mapped.counts.STAR, title = "S. lyc.  STAR mapped.  Default parameters")
lyc.count.comparison.1 <- CompareCounts(lyc.known.counts, lyc.mapped.counts, chrom.separate=FALSE, title = "S. lyc.  STAR mapped.  Default parameters FeatureCounts counting")
```

_S. lyc_ maps much better.  What is messing up the _S. pen_ mapping?

##Investigate...
Lets take a look at the bam file and extract reads from a few genes with 0 mapped reads.
```{r, echo=FALSE,results='hide'}
reads <- scanBam(file="spen_sim_1/STAR_1Aligned.sortedByCoord.out.bam",
                 param = ScanBamParam(what=scanBamWhat(),
                                      tag=c("NH","HI","AS","nM")))[[1]]
#note: DO NOT directly convert reads to a data frame.  Uses lots of memory.  instead remove the very large reads column.  See below.

reads <- c(reads[names(reads)!="tag"],reads$tag) #unpack each element of reads$tag and add it to reads

#add an element indicating whether or not the read came from a gene with no reads mapping to the pen version
genes.zero.map <- pen.count.comparison.1$id[pen.count.comparison.1$count.known>0 & pen.count.comparison.1$count.mapped==0]
reads$gene <- unlist(strsplit(reads$qname,";"))[c(FALSE,TRUE,FALSE,FALSE)]
lapply(reads, head)
reads$pen.zero.map <- reads$gene %in% genes.zero.map

table(reads$flag,reads$pen.zero.map)
table(reads$NH,reads$pen.zero.map) #number of hits

reads.df <- with(reads,data.frame(qname,rname,pos,qwidth,flag,cigar,NH,HI,AS,nM,gene,pen.zero.map,stringsAsFactors=FALSE))
reads.df$gene.lyc <- substr(reads.df$gene,18,38)
  
reads.df$multimap <- reads.df$NH>1

reads.df$pen.gene.length <- pen.gene.length[reads.df$gene]
reads.df$lyc.gene.length <- lyc.gene.length[reads.df$gene]

reads.df$pen.lyc.gene.length.dif <- reads.df$pen.gene.length - reads.df$lyc.gene.length

reads.df$pen.lyc.gene.length.ratio <- reads.df$pen.gene.length / reads.df$lyc.gene.length
```

## Reads plotted by genes hit and mismatches
```{r, fig_height=5,fig_width=8, echo=FALSE}
ggplot(reads.df,aes(x=as.factor(NH),y=nM,group=NH)) + geom_point(stat="sum") + scale_size(breaks=seq(0,1,.1),range=c(1,15)) + xlab("Number of genes hit") + ylab("Number of mismatches")
```


```{r not_used, echo=FALSE, eval=FALSE}
ggplot(reads.df,aes(x=as.factor(NH),y=pen.gene.length,fill=pen.zero.map)) + geom_violin()

ggplot(reads.df,aes(x=as.factor(NH),y=lyc.gene.length,fill=pen.zero.map)) + geom_violin()

ggplot(reads.df,aes(x=as.factor(NH),y=pen.gene.length)) + geom_violin()

ggplot(reads.df,aes(x=as.factor(NH),y=pen.lyc.gene.length.ratio,fill=multimap)) + geom_violin()

ggplot(reads.df,aes(x=pen.zero.map,y=pen.gene.length,fill=multimap)) + geom_boxplot()

ggplot(reads.df,aes(x=pen.zero.map,y=pen.lyc.gene.length.ratio,fill=multimap)) + geom_violin()
```

## Gene length effects

```{r, echo=FALSE,results='hide'}
ggplot(pen.count.comparison.1,aes(x=gene.length.diff.pen.lyc,y=count.ratio.known.mapped)) + geom_point(alpha=0.1) + scale_y_log10() + scale_x_log10(breaks=c(1,10,100,200,300,500,1000))
```


## Gene length effects 2

```{r, echo=FALSE, results='hide'}
ggplot(pen.count.comparison.1,aes(x=gene.length.ratio.pen.lyc,y=count.ratio.known.mapped))  + scale_y_log10() + scale_x_log10(breaks=c(.1,.5,seq(1,2,.2),3,5,10)) + geom_hline(yintercept=1,color="blue") + geom_vline(xintercept=1,color="blue") + geom_point(alpha=.1)
```


## Remove genes
Remove genes with gene length ratio > 1.3 or gene length difference > 300bp
```{r, echo=FALSE, results='hide'}
#reasonable cutoffs might be a gene.length.ratio > 1.3 or a gene length difference of > 300

pen.count.comparison.1.cutoff1.3 <- pen.count.comparison.1[pen.count.comparison.1$gene.length.ratio.pen.lyc < 1.3,]
nrow(pen.count.comparison.1)
nrow(pen.count.comparison.1.cutoff1.3)
with(pen.count.comparison.1.cutoff1.3,cor(count.known,count.mapped))

pen.count.comparison.1.cutoff300 <- pen.count.comparison.1[pen.count.comparison.1$gene.length.diff.pen.lyc < 300,]
nrow(pen.count.comparison.1)
nrow(pen.count.comparison.1.cutoff300)
with(pen.count.comparison.1.cutoff300,cor(count.known,count.mapped))

pen.count.comparison.1.cutoff300.1.3 <- pen.count.comparison.1[pen.count.comparison.1$gene.length.diff.pen.lyc < 300 & pen.count.comparison.1$gene.length.ratio.pen.lyc < 1.3,]
nrow(pen.count.comparison.1)
nrow(pen.count.comparison.1.cutoff300.1.3)
with(pen.count.comparison.1.cutoff300.1.3,cor(count.known,count.mapped))

length.cutoff.plot.data <- as.data.frame(t(sapply(seq(0,max(pen.count.comparison.1$gene.length.diff.pen.lyc),50),function(x) 
  with(
    pen.count.comparison.1[pen.count.comparison.1$gene.length.diff.pen.lyc <= x ,],
    c(cutoff=x,genes=length(count.known),correlation=cor(count.known,count.mapped))))))
length.cutoff.plot.data$type <- "difference"


ratio.cutoff.plot.data <- as.data.frame(t(sapply(seq(1,max(pen.count.comparison.1$gene.length.ratio.pen.lyc),.1),function(x) 
  with(
    pen.count.comparison.1[pen.count.comparison.1$gene.length.ratio.pen.lyc <= x ,],
    c(cutoff=x,genes=length(count.known),correlation=cor(count.known,count.mapped))))))
ratio.cutoff.plot.data$type <- "ratio"

combined.cutoff.plot.data <-rbind(length.cutoff.plot.data,ratio.cutoff.plot.data)

ggplot(combined.cutoff.plot.data,aes(x=genes,y=correlation,color=type)) + geom_line() 

#ggplot(length.cutoff.plot.data,aes(x=genes,y=correlation,label=cutoff)) + geom_line() + geom_text(aes(label=cutoff),size=2.5,vjust=-1,hjust=-.3) 
```

## how many reads map to the wrong gene?

```{r mismapping, echo=FALSE, results='hide'}
lyc.transcript.gr <- import("~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_gene_models.gff3",feature.type="mRNA")
reads.df.map <- na.omit(reads.df)
reads.gr <- with(reads.df.map,GRanges(seqnames=rname,
                    ranges = IRanges(start=pos,
                                     width = qwidth, #note that this is not precisely correct because of introns,etc
                                     names=qname)))
hits <- findOverlaps(reads.gr,lyc.transcript.gr,ignore.strand=TRUE)
sum(reads.df.map$gene.lyc[queryHits(hits)] != lyc.transcript.gr$Name[subjectHits(hits)]) / length(hits)
reads.df.map.single <- reads.df.map[reads.df.map$NH==1,]
reads.gr.single <- with(reads.df.map.single,GRanges(seqnames=rname,
                    ranges = IRanges(start=pos,
                                     width = qwidth, #note that this is not precisely correct because of introns,etc
                                     names=qname)))
hits.single <- findOverlaps(reads.gr.single,lyc.transcript.gr,ignore.strand=TRUE)
sum(reads.df.map.single$gene.lyc[queryHits(hits.single)] != lyc.transcript.gr$Name[subjectHits(hits.single)]) / length(hits.single)

reads.df.map.single.overlap <- reads.df.map.single[queryHits(hits.single),] #only keep reads that overlap a transcript

reads.df.map.single.overlap$gene.mapped.to <- lyc.transcript.gr$Name[subjectHits(hits.single)]

#remove chromosome zero

reads.df.map.single.overlap <- reads.df.map.single.overlap[!grepl("Solyc00g",paste(reads.df.map.single.overlap$gene.lyc,reads.df.map.single.overlap$gene.mapped.to)),] #not very different

with(reads.df.map.single.overlap,sum(gene.lyc!=gene.mapped.to)/length(gene.lyc))

#are reads represented more than once?
length(unique(reads.df.map.single.overlap$qname))/nrow(reads.df.map.single.overlap)
#yes.  So reads are overlapping with multiple genes.  Presumably this is due to overlaping genes in the annotation.

reads.df.map.single.overlap$chrom.lyc <- substr(reads.df.map.single.overlap$gene.lyc,6,8)
reads.df.map.single.overlap$chrom.mapped.to <- substr(reads.df.map.single.overlap$gene.mapped.to,6,8)


reads.df.map.single.overlap$mismap <- reads.df.map.single.overlap$gene.lyc != reads.df.map.single.overlap$gene.mapped.to
head(reads.df.map.single.overlap,50)
head(reads.df.map.single.overlap[reads.df.map.single.overlap$mismap,c("gene.lyc","gene.mapped.to")],50)
#yes the overlapping annotaiton seems to explain some of it.  Can check more
reads.df.map.single.overlap <- within(reads.df.map.single.overlap, mapnear <- 
                                        (abs(as.numeric(substr(gene.lyc,9,14)) - as.numeric(substr(gene.mapped.to,9,14))) < 40) & 
                                        chrom.lyc == chrom.mapped.to)
head(reads.df.map.single.overlap[reads.df.map.single.overlap$mismap,c("gene.lyc","gene.mapped.to","mapnear")],100)
with(reads.df.map.single.overlap,sum(mapnear & mismap) / sum(mismap))

#so if we get rid of the "mapnear" mismaps how many mismaps are left?
sum(reads.df.map.single.overlap$mismap[!reads.df.map.single.overlap$mapnear]) / nrow(reads.df.map.single.overlap)

#save.image("rnaseqSim.Rdata")
save(list=grep("reads",ls(),invert = TRUE,value=T),file="rnaseqSim_no_read_data.Rdata")
```

Percent reads mapped to wrong gene:
```{r }
with(reads.df.map.single.overlap,sum(mapnear & mismap) / sum(mismap))
```

Percent reads mapped to wrong gene (distant):
```{r}
sum(reads.df.map.single.overlap$mismap[!reads.df.map.single.overlap$mapnear]) / nrow(reads.df.map.single.overlap)
```


## why mismapping?
Investigate by looking at where S.pen genes map on S.lyc chromosomes.

Are the S. pen "Orthlogs" really mapping to their cognate S.lyc gene?

Use BLAT to map S. pen predicted cDNAs to S. lyc genome.

```{r BLAT install, eval=FALSE, engine='bash', echo=FALSE}
brew install blat
```

```{r run BLAT, engine='bash', eval=FALSE, echo=FALSE}
blat ~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/S_lycopersicum_chromosomes.2.50.fa -q=rna -t=dna -minMatch=4 ~/Sequences/ref_genomes/S.pen/Spenn-v2-cds-annot_orthlogs_only.fa -maxIntron=20000 penCDS_to_lycGENME.psl
#setting minMatch to 4 reduces number of overlaps from ~6300 to 3300
```

## Map _real_ reads as comparision
```{r map_real,eval=FALSE, echo=FALSE}
RunStar(fasta = "/Volumes/temp-o-matic/temp_SolRAID_restore/Solexa_runs_Data/Filtered_fastq_by_seedling_exp/merged_files/PEN.seedlings.fq",
        prefix = "STAR_1",
        dir = "spen_real",
        n=12,
        param.file = "../STAR.params.whitney.1")
```


Now look in IGV (Note: Need to use IGVtools to sort and index the .psl file)

```{r}
head(reads.df.map.single.overlap[reads.df.map.single.overlap$mismap,c("qname","gene.lyc","gene.mapped.to","mapnear")],100)
sort(table(reads.df.map.single.overlap$gene.lyc[reads.df.map.single.overlap$mismap]))
```

## 5 examples of genes with mismapping

Solyc02g090930.2.1 (12): Tandem Repeat with Solyc02g090940.2.1
Solyc04g072480.2.1 (30): Nothing obviously strange
Solyc03g051930.2.1 (70): PEN gene spans two LYC genes
Solyc02g079850.2.1 (150): PEN gene spans two LYC genes
Solyc01g110960.2.1 (497): Much Confusion

## 5 examples of genes with zero mapping

```{r, echo=FALSE}
pen.count.comparison.1.cutoff300.1.3[pen.count.comparison.1.cutoff300.1.3$count.ratio==Inf,c("lyc.id","count.known","gene.length.ratio.pen.lyc")]
```

Solyc01g010050.2: Two overlapping LYC transcripts (note this is fixed when using FeatureCounts from subread)
Solyc01g060020.2: Multiple overlapping LYC transcripts
Solyc05g023780.1: Repetitive region
Solyc08g015710.1: Very small region of homology
Solyc11g056540.1: BLAT did not find a match

## How to deal with this?

Many of these issues could be dealt with by
1. Eliminating genes with overlapping LYC to LYC or PEN to LYC transcripts. 
2. Using the BLAT results to eliminate transcripts with poor homology.

```{r, echo=FALSE}
lyc.lyc.overlaps <- findOverlaps(lyc.transcript.gr,lyc.transcript.gr) #all overlaps including self on self
lyc.lyc.overlaps <- lyc.lyc.overlaps[queryHits(lyc.lyc.overlaps)!=subjectHits(lyc.lyc.overlaps),] #limit to non-self overlaps
lyc.lyc.overlaps <- substr(unique(mcols(lyc.transcript.gr)[queryHits(lyc.lyc.overlaps),"Name"]),1,16)

pen.transcript.gr <- PSL2Granges(file="penCDS_to_lycGENME.psl")
pen.pen.overlaps <- findOverlaps(pen.transcript.gr,pen.transcript.gr) #all overlaps including self on self

#need additional step to limit to non-self overlaps because BLAT returns multiple hits in the same region.  Make sure that the overlap is with the same gene
pen.pen.overlaps <- pen.pen.overlaps[names(pen.transcript.gr)[queryHits(pen.pen.overlaps)]!=names(pen.transcript.gr)[subjectHits(pen.pen.overlaps)]] 

pen.pen.overlaps <- unique(mcols(pen.transcript.gr)[queryHits(pen.pen.overlaps),"lyc.ID"]) 
```

## Original
```{r, echo=FALSE}
pen.count.comparison.1$flag <- "none"
pen.count.comparison.1 <- within(pen.count.comparison.1,{
                                 flag[pen.count.comparison.1$lyc.id %in% lyc.lyc.overlaps] <- "lyc.lyc.overlap"
                                 flag[pen.count.comparison.1$lyc.id %in% pen.pen.overlaps] <- "pen.pen.overlap"
                                 }
                                 )
with(pen.count.comparison.1,cor(count.known,count.mapped))
```

## With bad annotations removed
Genes where more than one _S.lyc_ or more than one _S.pen_ annotation overlap are removed.
```{r}
with(pen.count.comparison.1[pen.count.comparison.1$flag=="none",],cor(count.known,count.mapped))
```
Pretty good!

# Mapping to cDNA refernce with kallisto

[Kallisto](https://pachterlab.github.io/kallisto/about.html) is a read quantification software that works without aligning.  I would like to see how it performs in this context.

## installation
mac command line
```{r, eval=FALSE, engine='bash'}
brew install kallisto
```

## build index
only needs to be done once:
```{r, eval=FALSE, engine='bash'}
kallisto index -i ITAG2.4._cds.pen.orthlogsonly.kai ~/Sequences/ref_genomes/tomato/ITAG2.4_Chromo2.5/ITAG2.4_cds.pen.orthologs.only.fasta
```
But I wonder if different kmers would give different results

## For kallisto fasta needs to be converted to fastq
Download [converter](https://code.google.com/archive/p/fasta-to-fastq/downloads)
```{r, engine='bash',eval=FALSE}
gzcat  sample_01_renamed.fasta.gz | perl ~/bin/fasta_to_fastq.pl  - | gzip > sample_01_renamed.fastq.gz
```


## run kallisto
```{r, eval=TRUE, engine='bash'}
RunKallisto(fasta = "spen_sim_1/sample_01_renamed.fastq.gz", index = "ITAG2.4._cds.pen.orthlogsonly.kai", dir = "spen_sim_1/kallisto_cDNA" )
```

## Load in mapped counts
```{r get_mapped_counts_kallisto }
pen.mapped.counts <- GetMappedCounts(dir = "spen_sim_1/kallisto", type="kallisto-transcripts")
```

## _S. pennellii_
Compare known to mapped counts  
```{r compare_spen1_kallisto, echo=FALSE, results='hide', fig.width=8, fig.height=5}
pen.count.comparison.1 <- CompareCounts(pen.known.counts, pen.mapped.counts, chrom.separate=FALSE, title = "S. pen. kallisto mapped to cDNA.  Default parameters.  Kallisto counting")
```

## Remove overlapping genes

## Original
```{r, echo=FALSE}
pen.count.comparison.1$flag <- "none"
pen.count.comparison.1 <- within(pen.count.comparison.1,{
                                 flag[pen.count.comparison.1$lyc.id %in% lyc.lyc.overlaps] <- "lyc.lyc.overlap"
                                 flag[pen.count.comparison.1$lyc.id %in% pen.pen.overlaps] <- "pen.pen.overlap"
                                 }
                                 )
with(pen.count.comparison.1,cor(count.known,count.mapped))
```

## With bad annotations removed
Genes where more than one _S.lyc_ or more than one _S.pen_ annotation overlap are removed.
```{r}
with(pen.count.comparison.1[pen.count.comparison.1$flag=="none",],cor(count.known,count.mapped))
```

Pretty good!


